/** Task: Different soring algorithms *  @author Richard Szeto, Frank Carrano *  @course CS 111C *  @asmt   Homework 6 * *//******************************************************************** * Class for sorting an array of Comparable objects from smallest to  * largest. ********************************************************************/public class SortArray{    /*****************Chapter 11 Problem 11**********************/    public static <T extends Comparable<? super T>>         boolean isSorted(T[] array)    {        if(array != null)        {            if(array.length >= 1)            {                int index;                T prevData = array[0];                for(index = 1; index < array.length &&                     array[index] != null &&                        prevData.compareTo(array[index]) <= 0; index++)                {                    prevData = array[index];                }                if(index == array.length)                    return true;                else if(array[index] == null)                    return true;                else                    return false;            }            else                return true;        }        else            return false;    }    /** Task: Sorts the first n objects in an array into ascending order.     *  @param a  an array of Comparable objects     *  @param n  an integer > 0 */    public static <T extends Comparable<? super T>>         void selectionSort(T[] a, int n)    {        for (int index = 0; index < n - 1; index++)        {            int indexOfNextSmallest = getIndexOfSmallest(a, index, n - 1);            swap(a, index, indexOfNextSmallest);            // Assertion: a[0] <= a[1] <= . . . <= a[index] <= all other a[i]        } // end for    } // end selectionSort        /** Task: Finds the index of the smallest value in a portion of an      *        array.     *  @param a      an array of Comparable objects     *  @param first  an integer >= 0 and < a.length that is the index of      *                the first array element to consider     *  @param last   an integer >= first and < a.length that is the index      *                of the last array element to consider     *  @return the index of the smallest value among     *          a[first], a[first + 1], . . . , a[last] */    private static <T extends Comparable<? super T>>        int getIndexOfSmallest(T[] a, int first, int last)    {        T min = a[first];        int indexOfMin = first;        for (int index = first + 1; index <= last; index++)        {            if (a[index].compareTo(min) < 0)            {                min = a[index];                indexOfMin = index;                // Assertion: min is the smallest of a[first] through a[index].            } // end if        } // end for        return indexOfMin;    } // end getIndexOfSmallest        /** Task: Swaps the array elements a[i] and a[j].     *  @param a  an array of objects     *  @param i  an integer >= 0 and < a.length     *  @param j  an integer >= 0 and < a.length */    private static void swap(Object[] a, int i, int j)    {        Object temp = a[i];        a[i] = a[j];        a[j] = temp;         // for testing        System.out.print("a: ");        for(int index = 0; index < a.length; index++)            System.out.print(a[index] + " ");        System.out.println();    } // end swap    /**  Task: Sorts the first n objects in an array into ascending order.     *   @param a     an array of Comparable objects     *   @param first an integer >= 0 and < a.length that is the index of     *                of the first array element to consider     *   @param last  an integer >= first and < a.length that is the index     *                of the last array element to consider     */    public static <T extends Comparable<? super T>>        void insertionSort(T[] a, int first, int last)    {        for(int unsorted = first + 1; unsorted <= last; unsorted++)        {            T firstUnsorted = a[unsorted];            insertInOrder(firstUnsorted, a, first, unsorted - 1);        }    } // end insertionSort    /** Task: Places first element in unsorted section into the     *        approprate sorted place in the sorted section     *  @param element a Comparable object     *  @param begin   an integer >= 0 and < a.length that is the index of     *                 the first array element in the sorted section     *  @param end     an integer >= first and < a.length that is the index     *                 of the last element in the sorted section     */    private static <T extends Comparable<? super T>>        void insertInOrder(T element, T[] a, int begin, int end)    {        int index = end;        while( (index >= begin) && (element.compareTo(a[index]) < 0) )        {            a[index + 1] = a[index];            a[index] = null;            index--;            // for testing            System.out.print("a: ");            for(int i = 0; i < a.length; i++)            {                System.out.print(a[i] + " ");            }            System.out.println();        }        a[index + 1] = element;        // for testing        System.out.print("a: ");        for(int i = 0; i < a.length; i++)        {            System.out.print(a[i] + " ");        }        System.out.println();    } // end insertInOrder    /**  Task: Sorts the first n objects in an array into ascending order.     *   @param a     an array of Comparable objects     *   @param first an integer >= 0 and < a.length that is the index of     *                of the first array element to consider     *   @param last  an integer >= first and < a.length that is the index     *                of the last array element to consider     */    public static <T extends Comparable<? super T>>       void shellSort(T[] a, int first, int last)    {        int n = last - first + 1; // number of array elements          for (int space = n / 2; space > 0; space = space / 2)        {            //for testing            System.out.println();            System.out.println("Space = " + space);            for (int begin = first; begin < first + space; begin++)                incrementalInsertionSort(a, begin, last, space);        } // end for    } // end shellSort    /**  Task: Sorts the first n objects in an array into ascending order.     *   @param a     an array of Comparable objects     *   @param first an integer >= 0 and < a.length that is the index of     *                of the first array element to consider     *   @param last  an integer >= first and < a.length that is the index     *                of the last array element to consider     */    public static <T extends Comparable<? super T>>       void shellSortImproved(T[] a, int first, int last)    {        int n = last - first + 1; // number of array elements          for (int space = n / 2; space > 0; space = space / 2)        {            if(space%2 == 0)                space++;            //for testing            System.out.println();            System.out.println("Space = " + space);            for (int begin = first; begin < first + space; begin++)                incrementalInsertionSort(a, begin, last, space);        } // end for    } // end shellSort    /** Task: Sorts equally spaced elements of an array into      *        ascending order.     *  @param a      an array of Comparable objects     *  @param first  the integer index of the first array element to     *                consider; first >= 0 and < a.length     *  @param last   the integer index of the last array element to     *                consider; last >= first and < a.length     *  @param space  the difference between the indices of the      *                elements to sort      */     private static <T extends Comparable<? super T>>        void incrementalInsertionSort(T[] a, int first, int last,                                       int space)    {        int unsorted, index;          for (unsorted = first + space; unsorted <= last;             unsorted = unsorted + space)        {            T firstUnsorted = a[unsorted];                for (index = unsorted - space; (index >= first) &&                    (firstUnsorted.compareTo(a[index]) < 0);                        index = index - space)            {                a[index + space] = a[index];                a[index] = null; // for testing                // for testing                System.out.print("a: ");                for(int i = 0; i < a.length; i++)                    System.out.print(a[i] + " ");                System.out.println();            } // end for                a[index + space] = firstUnsorted;             // for testing            System.out.print("a: ");            for(int i = 0; i < a.length; i++)                System.out.print(a[i] + " ");            System.out.println();        } // end for    } // end incrementalInsertionSort    /** Task: Sorts an array in ascending order     *  @param a     array of Comparable objects     *  @param first position of first element in the array to be sorted     *  @param last  position of last element in the array to be sorted     */    public static <T extends Comparable<? super T>>       void mergeSort(T[] a, int first, int last)    {        T[] tempArray = (T[])new Comparable<?>[a.length];        mergeSort(a, tempArray, first, last);    } // end mergeSort    /** Task: Sorts an array in ascending order     *  @param a         array of Comparable objects to be sorted     *  @param tempArray temporary array of Comparable objects     *  @param first     position of first element in the array to be sorted     *  @param last      position of last element in the array to be sorted     *     */    private static <T extends Comparable<? super T>>        void mergeSort(T[] a, T[] tempArray, int first, int last)    {        if(first < last)        {            int mid = (first + last) / 2;            mergeSort(a, tempArray, first, mid);            mergeSort(a, tempArray, mid + 1, last);            merge(a, tempArray, first, mid, last);        } // end if    } // end mergeSort    /** Task: merge two arrays into sorted order     *  @param a         array of Comparable objects to be sorted     *  @param tempArray temporary array of Comparable objects     *  @param first     position of first element in the array to be sorted     *  @param mid       position of middle element in the array to be sorted     *  @param last      position of the last element in the array to be sorted     *     */    private static <T extends Comparable<? super T>>        void merge(T[] a, T[] tempArray, int first, int mid, int last)    {        int beginHalf1 = first;        int endHalf1 = mid;        int beginHalf2 = mid + 1;        int endHalf2 = last;        int index = 0;        while( (beginHalf1 <= endHalf1) && (beginHalf2 <= endHalf2) )        {            if(a[beginHalf1].compareTo(a[beginHalf2]) < 0)            {                tempArray[index] = a[beginHalf1];                beginHalf1++;                // for testing                System.out.print("tempArray: ");                for(int i = 0; i <= index; i++)                    System.out.print(tempArray[i] + " ");                System.out.println();            }            else            {                tempArray[index] = a[beginHalf2];                beginHalf2++;                // for testing                System.out.print("tempArray: ");                for(int i = 0; i <= index; i++)                    System.out.print(tempArray[i] + " ");                System.out.println();            } // end if            index++;        } // end while        if(beginHalf1 > endHalf1)        {            for(;beginHalf2 <= endHalf2; beginHalf2++, index++)            {                tempArray[index] = a[beginHalf2];                // for testing                System.out.print("tempArray: ");                for(int i = 0; i <= index; i++)                    System.out.print(tempArray[i] + " ");                System.out.println();            } // end for        }        else if(beginHalf2 > endHalf2)        {            for(;beginHalf1 <= endHalf1; beginHalf1++, index++)            {                tempArray[index] = a[beginHalf1];                // for testing                System.out.print("tempArray: ");                for(int i = 0; i <= index; i++)                    System.out.print(tempArray[i] + " ");                System.out.println();            } // end for        }// end if        index = 0;        for(int i = first; i <= last; i++, index++)                a[i] = tempArray[index];        // for testing        System.out.print("a: ");        for(int i = 0; i < a.length; i++)            System.out.print(a[i] + " ");        System.out.println();    } // end merge    /** Task: Sorts an array into ascending order. Uses quick sort with     *        median-of-three pivot selection for arrays of at least      *        MIN_SIZE elements, and uses insertion sort for other arrays.     */    public static <T extends Comparable<? super T>>       void quickSort(T[] a, int first, int last)    {        int MIN_SIZE = 3;        if (last - first + 1 < MIN_SIZE)        {            System.out.println("Using insertion sort");            insertionSort(a, first, last);            System.out.println("End of insertion sort");        }        else        {            // create the partition: Smaller | Pivot | Larger            int pivotIndex = partition(a, first, last);            System.out.println("pivotIndex outer = " + pivotIndex);                // sort subarrays Smaller and Larger            quickSort(a, first, pivotIndex - 1);            quickSort(a, pivotIndex + 1, last);        } // end if    } // end quickSort    /** Task: Partitions an array as part of quick sort into two subarrays     *        called Smaller and Larger that are separated by a single     *        element called the pivot.      *        Elements in Smaller are <= pivot and appear before the      *        pivot in the array.     *        Elements in Larger are >= pivot and appear after the      *        pivot in the array.     *  @param a      an array of Comparable objects     *  @param first  the integer index of the first array element;      *                first >= 0 and < a.length      *  @param last   the integer index of the last array element;      *                last - first >= 3; last < a.length     *  @return the index of the pivot */    private static <T extends Comparable<? super T>>            int partition(T[] a, int first, int last)    {        int mid = (first + last)/2;        sortFirstMiddleLast(a, first, mid, last);              // Assertion: The pivot is a[mid]; a[first] <= pivot and         // a[last] >= pivot, so do not compare these two array elements        // with pivot.              // move pivot to next-to-last position in array        swap(a, mid, last - 1);        int pivotIndex = last - 1;        T pivot = a[pivotIndex];        System.out.println("pivotIndex inner = " + pivotIndex);        System.out.println("pivot = " + pivot.toString());              // determine subarrays Smaller = a[first..endSmaller]        // and                 Larger  = a[endSmaller+1..last-1]        // such that elements in Smaller are <= pivot and         // elements in Larger are >= pivot; initially, these subarrays are empty        int indexFromLeft = first + 1;         int indexFromRight = last - 2;         System.out.println("indexFromLeft = " + indexFromLeft);        System.out.println("indexFromRight = " + indexFromRight);        boolean done = false;        while (!done)        {            // starting at beginning of array, leave elements that are < pivot;            // locate first element that is >= pivot; you will find one,            // since last element is >= pivot            while (a[indexFromLeft].compareTo(pivot) < 0)            {                indexFromLeft++;                System.out.println("indexFromLeft = " + indexFromLeft);            }                      // starting at end of array, leave elements that are > pivot;             // locate first element that is <= pivot; you will find one,             // since first element is <= pivot            while (a[indexFromRight].compareTo(pivot) > 0)            {                indexFromRight--;                System.out.println("indexFromRight = " + indexFromRight);            }                      assert a[indexFromLeft].compareTo(pivot) >= 0 &&                a[indexFromRight].compareTo(pivot) <= 0;                           if (indexFromLeft < indexFromRight)            {                swap(a, indexFromLeft, indexFromRight);                indexFromLeft++;                indexFromRight--;                System.out.println("indexFromLeft = " + indexFromLeft);                System.out.println("indexFromRight = " + indexFromRight);            }            else                 done = true;        } // end while              // place pivot between Smaller and Larger subarrays        swap(a, pivotIndex, indexFromLeft);        pivotIndex = indexFromLeft;        System.out.println("pivotIndex inner = " + pivotIndex);              // Assertion:        //   Smaller = a[first..pivotIndex-1]        //   Pivot = a[pivotIndex]        //   Larger = a[pivotIndex+1..last]              return pivotIndex;     } // end partition    /** Task: Sorts the first, middle, and last elements of an      *        array into ascending order.     *  @param a      an array of Comparable objects     *  @param first  the integer index of the first array element;      *                first >= 0 and < a.length      *  @param mid    the integer index of the middle array element     *  @param last   the integer index of the last array element;      *                last - first >= 2, last < a.length */    private static <T extends Comparable<? super T>>        void sortFirstMiddleLast(T[] a, int first, int mid, int last)    {        order(a, first, mid); // make a[first] <= a[mid]        order(a, mid, last);  // make a[mid] <= a[last]        order(a, first, mid); // make a[first] <= a[mid]    } // end sortFirstMiddleLast    /** Task: Orders two given array elements into ascending order     *        so that a[i] <= a[j].     *  @param a  an array of Comparable objects     *  @param i  an integer >= 0 and < array.length     *  @param j  an integer >= 0 and < array.length */    private static <T extends Comparable<? super T>>        void order(T[] a, int i, int j)    {        if (a[i].compareTo(a[j]) > 0)            swap(a, i, j);    } // end order} // end SortArray